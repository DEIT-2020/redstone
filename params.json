{"name":"Bloodless","tagline":"A metadata driven microframework for Dart.","body":"##Introduction\r\n\r\nBloodless is a simple server-side microframework for Dart.\r\n\r\n```dart\r\n\r\nimport 'package:bloodless/server.dart' as app;\r\n\r\n@app.Route(\"/\")\r\nhelloWorld() => \"Hello, World!\";\r\n\r\nmain() {\r\n  app.setupConsoleLog();\r\n  app.start();\r\n}\r\n\r\n```\r\n\r\n```\r\n$ dart hello.dart \r\nINFO: 2014-02-24 13:16:19.086: Configured target for / : .helloWorld\r\nINFO: 2014-02-24 13:16:19.102: Setting up VirtualDirectory for /home/user/project/web - followLinks: false - jailRoot: true - index files: [index.html]\r\nINFO: 2014-02-24 13:16:19.121: Running on 0.0.0.0:8080\r\n```\r\n\r\n**NOTE: Bloodless took a lot of ideas and concepts from the Python's [Flask](http://flask.pocoo.org/) microframework**\r\n\r\n## Installation\r\n\r\n* Create a new Dart package ([manually](http://pub.dartlang.org/doc/) or through Dart Editor)\r\n* Add bloodless as a dependency in `pubspec.yaml` file\r\n\r\n```\r\nname: my_app\r\n dependencies:\r\n   bloodless: any\r\n```\r\n\r\n- Run `pub get` to update dependencies\r\n- Create a `bin` directory\r\n- Create a `server.dart` file under the `bin` directory\r\n\r\n```dart\r\n\r\nimport 'package:bloodless/server.dart' as app;\r\n\r\n@app.Route(\"/\")\r\nhelloWorld() => \"Hello, World!\";\r\n\r\nmain() {\r\n  app.setupConsoleLog();\r\n  app.start();\r\n}\r\n\r\n```\r\n\r\n- To run the server, create a launch configuration in Dart Editor, or use the `dart` command:\r\n\r\n```\r\n$ dart bin/server.dart\r\nINFO: 2014-02-24 13:16:19.086: Configured target for / : .helloWorld\r\nINFO: 2014-02-24 13:16:19.102: Setting up VirtualDirectory for /home/user/project/web - followLinks: false - jailRoot: true - index files: [index.html]\r\nINFO: 2014-02-24 13:16:19.121: Running on 0.0.0.0:8080\r\n```\r\n\r\n- Now head over to http://127.0.0.1:8080/, and you should see your hello world greeting.\r\n\r\n## Routing\r\n\r\nJust use the `Route` annotation to bind a method with a URL:\r\n\r\n```Dart\r\n@app.Route(\"/\")\r\nhelloWorld() => \"Hello, World!\";\r\n```\r\n\r\nThe returned value will be serialized to the client according to its type. For example, if the value is a String, the client will receive a *text/plain* response.\r\n\r\nReturned Value | Response type\r\n---------------|---------------\r\nString         | text/plain\r\nMap or List    | application/json\r\nFile           | (MimeType of the file)\r\n\r\nIf a Future is returned, then the framework will wait for its completion. \r\n\r\n```Dart\r\n@app.Route(\"/\")\r\nhelloWorld() => new Future(() => \"Hello, World!\");\r\n```\r\n\r\nFor other types, bloodless will convert the value to a String, and send it as *text/plain*.\r\n\r\nAlso, it's possible to override the content type of the response:\r\n\r\n```Dart\r\n@app.Route(\"/\", responseType: \"text/xml\")\r\ngetXml() => \"<root><node>text</node></root>\";\r\n```\r\n\r\n### Retrieving path parameters\r\n\r\nYou can easily bind URL parts to arguments:\r\n\r\n```Dart\r\n@app.Route(\"/user/:username\")\r\nhelloUser(String username) => \"hello $username\";\r\n```\r\n\r\nThe argument doesn't need to be a String. If it's an int, for example, bloodless will try to convert the value for you (if the conversion fails, a 400 status code is sent to the client).\r\n\r\n```Dart\r\n@app.Route(\"/user/:username/:addressId\")\r\ngetAddress(String username, int addressId) {\r\n  ...\r\n};\r\n```\r\n\r\nThe supported types are: int, double and bool\r\n\r\n### Retrieving query parameters\r\n\r\nUse the `QueryParam` annotation to access a query parameter\r\n\r\n```Dart\r\n@app.Route(\"/user\")\r\ngetUser(@app.QueryParam(\"id\") int userId) {\r\n  ...\r\n};\r\n```\r\n\r\nLike path parameters, the argument doesn't need to be a String. \r\n\r\n### HTTP Methods\r\n\r\nBy default, a route only respond to GET requests. You can change that with the `methods` arguments:\r\n\r\n```Dart\r\n@app.Route(\"/user/:username\", methods: const [app.GET, app.POST])\r\nhelloUser(String username) => \"hello $username\";\r\n```\r\n\r\n### Retrieving the request body\r\n\r\nYou can retrieve the request body as a form, json or text\r\n\r\n```Dart\r\n@app.Route(\"/adduser\", methods: const [app.POST])\r\naddUser(@app.Body(app.JSON) Map json) {\r\n  ...\r\n};\r\n```\r\n\r\n```Dart\r\n@app.Route(\"/adduser\", methods: const [app.POST])\r\naddUser(@app.Body(app.FORM) Map form) {\r\n  ...\r\n};\r\n```\r\n\r\n#### Multipart requests (file uploads)\r\n\r\nBy default, Bloodless will refuse any multipart request. If your method need to receive a multipart request, you can set `Route.allowMultipartRequest = true`. Example:\r\n\r\n```Dart\r\n@app.Route(\"/adduser\", methods: const [app.POST], allowMultipartRequest: true)\r\naddUser(@app.Body(app.FORM) Map form) {\r\n  ...\r\n};\r\n```\r\n\r\n### The request object\r\n\r\nYou can use the global `request` object to access the request's information and content:\r\n\r\n```Dart\r\n@app.Route(\"/user\", methods: const [app.GET, app.POST])\r\nuser() {\r\n  if (app.request.method == app.GET) {\r\n    ...\r\n  } else if (app.request.method == app.POST) {\r\n    \r\n    if (app.request.bodyType == app.JSON) {\r\n      var json = app.request.body;\r\n      ...\r\n    } else {\r\n      ...\r\n    }\r\n  }\r\n};\r\n```\r\n\r\nActually, the `request` object is a get method, that retrieves the request object from the current Zone. Since each request runs in its own zone, it's completely safe to use `request` at any time, even in async callbacks.\r\n\r\n## Interceptors\r\n\r\nEach request is actually a chain, composed by 0 or more interceptors, and a target. A target is a method annotated with `Route`, or a static file handled by a VirtualDirectory instance. An interceptor is a structure that allows you to apply a common behaviour to a group of targets. For example, you can use a interceptor to change the response of a group of targets, or to apply a security constraint.\r\n\r\n```Dart\r\n@app.Interceptor(r'/.*')\r\nhandleResponseHeader() {\r\n  app.request.response.headers.add(\"Access-Control-Allow-Origin\", \"*\");\r\n  app.chain.next();\r\n}\r\n```\r\n\r\n```Dart\r\n@app.Interceptor(r'/admin/.*')\r\nadminFilter() {\r\n  if (app.request.session[\"username\"] != null) {\r\n    app.chain.next();\r\n  } else {\r\n    app.chain.interrupt(statusCode: HttpStatus.UNAUTHORIZED);\r\n    //or app.redirect(\"/login.html\");\r\n  }\r\n}\r\n```\r\n\r\nWhen a request is received, the framework will execute all interceptors that matchs the URL, and then will look for a valid route. If a route is found, it will be executed, otherwise the request will be fowarded to the VirtualDirectory, which will look for a static file.\r\n\r\nEach interceptor must call the `chain.next()` or `chain.interrupt()` methods, otherwise, the request will be stucked. The `chain.next()` method can receive a callback, that is executed when the target completes. All callbacks are executed in the reverse order they are created. If a callback returns a `Future`, then the next callback will execute only when the future completes.\r\n\r\nFor example, consider this script:\r\n\r\n```Dart\r\n@app.Route(\"/\")\r\nhelloWorld() => \"target\\n\";\r\n\r\n@app.Interceptor(r'/.*', chainIdx: 0)\r\ninterceptor1() {\r\n  app.request.response.write(\"interceptor 1 - before target\\n\");\r\n  app.chain.next(() {\r\n    app.request.response.write(\"interceptor 1 - after target\\n\");\r\n  });\r\n}\r\n\r\n@app.Interceptor(r'/.*', chainIdx: 1)\r\ninterceptor2() {\r\n  app.request.response.write(\"interceptor 2 - before target\\n\");\r\n  app.chain.next(() {\r\n    app.request.response.write(\"interceptor 2 - after target\\n\");\r\n  });\r\n}\r\n\r\nmain() {\r\n\r\n  app.setupConsoleLog();\r\n  app.start();\r\n  \r\n}\r\n```\r\n\r\nWhen you access http://127.0.0.1:8080/, the result is:\r\n\r\n```\r\ninterceptor 1 - before target\r\ninterceptor 2 - before target\r\ntarget\r\ninterceptor 2 - after target\r\ninterceptor 1 - after target\r\n```\r\n\r\nLike the `request` object, the `chain` object is also a get method, that returns the chain of the current zone.\r\n\r\n**NOTE: By default, Bloodless won't parse the request body until all interceptors are called. If your interceptor need to inspect the request body, you must set `parseRequestBody = true`. Example:**\r\n\r\n```Dart\r\n@app.Interceptor(r'/service/.+', parseRequestBody: true)\r\nverifyRequest() {\r\n  //if parseRequestBody is not setted, request.body is null\r\n  print(app.request.body);\r\n  app.chain.next();\r\n}\r\n\r\n```\r\n\r\n\r\n**NOTE: You can also call `redirect()` or `abort()` instead of `chain.interrupt()`. The `abort()` call will invoke the corresponding error handler.**\r\n\r\n## Request attributes\r\n\r\nRequest attributes are objects that can be shared between interceptors and targets. They can be accessed through the `request.attributes` map. Also, if your method is annotated with `@Route`, they can be injected using the `Attr` annotation. Example:\r\n\r\n```Dart\r\n\r\n@app.Interceptor(r'/services/.+')\r\ndbConnInterceptor() {\r\n  var conn = new DbConn();\r\n  app.request.attributes[\"dbConn\"] = conn;\r\n  app.chain.next(() => conn.close());\r\n}\r\n\r\n@app.Route('/services/find')\r\nfind(@app.Attr() dbConn) {\r\n  ...\r\n}\r\n\r\n```\r\n\r\n## Groups\r\n\r\nYou can use classes to group routes and interceptors:\r\n\r\n```Dart\r\n@Group(\"/user\")\r\nclass UserService {\r\n  \r\n  @app.Route(\"/find\")\r\n  findUser(@app.QueryParam(\"n\") String name,\r\n           @app.QueryParam(\"c\") String city) {\r\n    ...\r\n  }\r\n\r\n  @app.Route(\"/add\", methods: const [app.POST])\r\n  addUser(@app.Body(app.JSON) Map json) {\r\n    ...\r\n  }\r\n}\r\n```\r\n\r\nThe prefix defined with the `Group` annotation, will be prepended in every route and interceptor inside the group.\r\n\r\n## Error handlers\r\n\r\nYou can define error handlers with the `ErrorHandler` annotation:\r\n\r\n```Dart\r\n@app.ErrorHandler(HttpStatus.NOT_FOUND)\r\nhandleNotFoundError() => app.redirect(\"/error/not_found.html\");\r\n```\r\n\r\nAlso, you can define a error handler for a specific urlPattern\r\n\r\n```Dart\r\n@app.ErrorHandler(HttpStatus.NOT_FOUND, urlPattern: r'/public/.+')\r\nhandleNotFoundError() => app.redirect(\"/error/not_found.html\");\r\n```\r\n\r\nIf you define a error handler inside a group, then the handler will be restricted to the group path.\r\n\r\n**NOTE: If a target throws a error, it can be accessed through the `chain.error` getter.**\r\n\r\n## Dependency injection\r\n\r\nBloodless uses the [di package](http://pub.dartlang.org/packages/di) to provide dependency injection.\r\n\r\nTo register a module, use the `addModule()` method:\r\n\r\n```Dart\r\nimport 'package:bloodless/server.dart' as app;\r\nimport 'package:di/di.dart';\r\n\r\nmain() {\r\n\r\n  app.addModule(new Module()\r\n       ..bind(ClassA)\r\n       ..bind(ClassB));\r\n  \r\n  app.setupConsoleLog();\r\n  app.start();\r\n\r\n}\r\n\r\n```\r\n\r\nFor methods annotated with `@Route`, you can inject objects using the `@Inject` annotation:\r\n\r\n```Dart\r\n@app.Route('/service')\r\nservice(@app.Inject() ClassA objA) {\r\n ...\r\n}\r\n```\r\n\r\nGroups can require objects using a constructor:\r\n\r\n```Dart\r\n@app.Group('/group')\r\nclass Group {\r\n\r\n  ClassA objA;\r\n  \r\n  Group(ClassA this.objA);\r\n  \r\n  @app.Route('/service')\r\n  service() {\r\n    ...\r\n  }\r\n\r\n}\r\n```\r\n\r\nInterceptors and error handlers can also require dependencies:\r\n\r\n```Dart\r\n@app.Interceptor(r'/services/.+')\r\ninterceptor(ClassA objA, ClassB objB) {\r\n  ...\r\n}\r\n\r\n\r\n@app.ErrorHandler(404)\r\nnotFound(ClassB objB) {\r\n  ...\r\n}\r\n```\r\n\r\n## Server configuration\r\n\r\nIf you invoke the `start()` method with no arguments, the server will be configured with default values:\r\n\r\nArgument       | Default Value\r\n---------------|---------------\r\nhost           | \"0.0.0.0\"\r\nport           | 8080\r\nstaticDir      | \"../web\"\r\nindexFiles     | [\"index.html\"]\r\nfollowLinks    | false\r\njailRoot       | true\r\n\r\n**NOTE: During development, you will probably need to set `followLinks = true` and `jailRoot = false`, since Dartium will request for .dart files that are not in web folder. Although, doing so in production environment can lead to security issues.**\r\n\r\n## Logging\r\n\r\nBloodless provides a helper method to set a simple log handler, that outputs the messages to the console:\r\n\r\n```Dart\r\napp.setupConsoleLog();\r\n```\r\n\r\nBy default, the log level is setted to INFO, which logs the startup process and errors. If you want to see all the log messages, you can set the level to ALL:\r\n\r\n```Dart\r\nimport 'package:logging/logging.dart';\r\n\r\n\r\nmain() {\r\n  app.setupConsoleLog(Level.ALL);\r\n  ...\r\n}\r\n```\r\n\r\nIf you want to output the messages to a different place (for example, a file), you can define your own log handler:\r\n\r\n```Dart\r\nLogger.root.level = Level.ALL;\r\nLogger.root.onRecord.listen((LogRecord rec) {\r\n  ...\r\n});\r\n```\r\n\r\n## Unit tests\r\n\r\nBloodless provides a simple API that you can use to easily test your server. \r\n\r\nFor example, consider you have the following service at `/lib/services.dart`\r\n\r\n```Dart\r\nlibrary services;\r\n\r\nimport 'package:bloodless/server.dart' as app;\r\n\r\n@app.Route(\"/user/:username\")\r\nhelloUser(String username) => \"hello, $username\";\r\n```\r\n\r\nA simple script to test this service would be:\r\n\r\n```Dart\r\nimport 'package:unittest/unittest.dart';\r\n\r\nimport 'package:bloodless/server.dart' as app;\r\nimport 'package:bloodless/mocks.dart';\r\n\r\nimport 'package:your_package_name/services.dart';\r\n\r\nmain() {\r\n\r\n  //load the services in 'services' library\r\n  setUp(() => app.setUp([#services]);\r\n  \r\n  //remove all loaded services\r\n  tearDown(() => app.tearDown());\r\n  \r\n  test(\"hello service\", () {\r\n    //create a mock request\r\n    var req = new MockRequest(\"/user/luiz\");\r\n    //dispatch the request\r\n    return app.dispatch(req).then((resp) {\r\n      //verify the response\r\n      expect(resp.statusCode, equals(200));\r\n      expect(resp.mockContent, equals(\"hello, luiz\"));\r\n    });\r\n  })\r\n  \r\n}\r\n```\r\n\r\n**NOTE: To learn more about unit tests in Dart, take a look at [this article](https://www.dartlang.org/articles/dart-unit-tests/).**\r\n\r\n## Deploying the app\r\n\r\nThe easiest way to build your app is using the [grinder](http://pub.dartlang.org/packages/grinder) library. Bloodless provides a simples task to properly copy the server's files to the build folder, which you can use in your build script. For example:\r\n\r\n* Create a `build.dart` file inside the `bin` folder\r\n```Dart\r\nimport 'package:grinder/grinder.dart';\r\nimport 'package:grinder/grinder_utils.dart';\r\nimport 'package:bloodless/tasks.dart';\r\n\r\nmain(List<String> args) {\r\n  defineTask('build', taskFunction: (GrinderContext ctx) => new PubTools().build(ctx));\r\n  defineTask('deploy_server', taskFunction: deployServer, depends: ['build']);\r\n  defineTask('all', depends: ['build', 'deploy_server']);\r\n  \r\n  startGrinder(args);\r\n}\r\n```\r\n\r\n* Instead of running `pub build` directly, you can call `build.dart` to properly build your app.\r\n\r\n* To run `build.dart` through Dart Editor, you need to create a command-line launch configuration, with the following parameters:\r\n\r\nParameter         | Value\r\n------------------|----------\r\nDart Script       | bin/build.dart\r\nWorking directory | (root path of your project)\r\nScript arguments  | all\r\n\r\n* To run `build.dart` through command line, you need to set the DART_SDK environment variable:\r\n\r\n```\r\n$ export DART_SDK=(path to dart-sdk)\r\n$ dart bin/build.dart all\r\n```\r\n\r\n**NOTE: You can improve your build script according to your needs.**\r\n\r\n","google":"UA-50600290-1","note":"Don't delete this file! It's used internally to help with page regeneration."}