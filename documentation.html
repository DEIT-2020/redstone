<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Redstone.dart - Server-side microframework for Dart</title>

    <!-- Bootstrap -->
    <link href="css/bootstrap.min.css" rel="stylesheet">
    <link href="css/github.css" rel="stylesheet">
    <link href="css/documentation.css" rel="stylesheet">
    <link href="css/footer.css" rel="stylesheet">

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
      <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->
  </head>
  <body data-spy="scroll" data-target="#affix-nav">
    <nav class="navbar navbar-default" role="navigation">
      <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header">
          <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
          <a class="navbar-brand" href="index.html">Redstone.dart</a>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
          <ul class="nav navbar-nav">
            <li class="active"><a href="#">Documentation</a></li>
            <li><a href="api/index.html">API Reference</a></li>
          </ul>
        </div><!-- /.navbar-collapse -->
      </div><!-- /.container-fluid -->
    </nav>

    <div class="container">
      <div class="row">
        <nav id="affix-nav" class="sidebar col-md-4 col-sm-4 hidden-xs">
          <ul class="nav sidenav" data-spy="affix" data-offset-top="290" data-offset-bottom="450">
            <li class="active"><a href="#introduction">Introduction</a></li>
            <li><a href="#quick_start_guide">Quick Start Guide</a>
              <ul class="nav">
                <li><a href="#installation">Installation</a></li>
                <li><a href="#feature_tour">Feature tour</a></li>
              </ul>
            </li>
            <li><a href="#reference">Reference</a>
              <ul class="nav">
                <li><a href="#routes">Routes</a></li>
                <li><a href="#interceptors">Interceptors</a></li>
                <li><a href="#error_handlers">Error handlers</a></li>
                <li><a href="#groups">Groups</a></li>
                <li><a href="#dependency_injection">Dependency injection</a></li>
                <li><a href="#importing_libraries">Importing libraries</a></li>
                <li><a href="#plugins">Plugins</a></li>
                <li><a href="#unit_test">Unit test</a></li>
                <li><a href="#server_configuration">Server Configuration</a></li>
                <li><a href="#deploy">Deploy</a></li>
              </ul>
            </li>
          </ul>
        </nav>
        <div class="col-md-8 col-sm-4 col-xs-12">
          <div id="introduction" class="section">
            <h1 class="page-header">Introduction</h1>
            <p>Redstone.dart is a server-side, metadata driven microframework for <a href="https://www.dartlang.org/">Dart</a>.</p>
            <h2>How does it work?</h2>
            <p>Redstone.dart allows you to easily publish your functions and classes through a web interface, by just adding some annotations to them. </p>
            <pre class="prettyprint code">
import 'package:redstone/server.dart' as app;

@app.Route("/")
helloWorld() => "Hello, World!";

main() {
  app.setupConsoleLog();
  app.start();
}</pre>
          <p>Does this example look familiar? Redstone.dart took a lot of ideas and concepts from the Python's <a href="http://flask.pocoo.org/">Flask</a> microframework.</p>
          </div>

          <div id="quick_start_guide" class="section">
            <h1 class="page-header">Quick Start Guide</h1>
            <div id="installation" class="subsection">
              <h2>Installation</h2>
              <p>Redstone.dart is available as a package at <a href="http://pub.dartlang.org/">pub</a>. So, all you have to do is add it as a dependency to your app.</p>
              <ul>
                <li>Create a new Dart package (<a href="http://pub.dartlang.org/doc/">manually</a> or through Dart Editor)</li>
              </ul>
              <ul>
                <li>Add Redstone.dart as a dependency in `pubspec.yaml` file</li>
              </ul>
              <pre class="code">
name: my_app
 dependencies:
   redstone: any</pre>
              <ul>
                <li>Run <code>pub get</code> to update dependencies</li>
              </ul>
              <ul>
                <li>Create a <code>bin</code> directory</li>
              </ul>
              <ul>
                <li>Create a <code>server.dart</code> file under the <code>bin</code> directory</li>
              </ul>
              <pre class="prettyprint code">
import 'package:redstone/server.dart' as app;

@app.Route("/")
helloWorld() => "Hello, World!";

main() {
  app.setupConsoleLog();
  app.start();
}</pre>
              <ul>
                <li>To run the server, create a launch configuration in Dart Editor, or use the <code>dart</code> command:</li>
              </ul>
              <pre>
$ dart bin/server.dart
<span style="color:#777">INFO: 2014-02-24 13:16:19.086: Configured target for / : .helloWorld
INFO: 2014-02-24 13:16:19.102: Setting up VirtualDirectory for /home/user/project/web - followLinks: false - jailRoot: true - index files: [index.html]
INFO: 2014-02-24 13:16:19.121: Running on 0.0.0.0:8080</span></pre>
              <ul>
                <li>Now head over to <a href="http://127.0.0.1:8080/">http://127.0.0.1:8080/</a>, and you should see your hello world greeting.</li>
              </ul>
            </div>
            <div id="feature_tour" class="subsection">
              <h2>Feature tour</h2>
              <h3>Routes</h3>
              <p>To bind a function with an URL, just use the <code>@Route</code> annotation</p>
              <pre class="prettyprint code">
@app.Route("/")
helloWorld() => "Hello, World!";</pre>
              <p>Redstone.dart will serialize the returned value for you. So, if your function returns a <code>List</code> or a <code>Map</code>, the client receives a JSON object:</p>
              <pre class="prettyprint code">
@app.Route("/user/find/:id")
getUser(String id) => {"name": "User", "login": "user"};</pre>
              <p>If your function depends on async operations, you can also return a <code>Future</code></p>
              <pre class="prettyprint code">
@app.Route("/service")
service() => doSomeAsyncOperation().then((_) => {"success": true});</pre>
              <p>You can easily bind path segments and query parameters</p>
              <pre class="prettyprint code">
@app.Route("/user/find/:type")
findUsers(String type, @app.QueryParam() String name) {
  ...
}</pre>
              <p>You can also bind the request body</p>
              <pre class="prettyprint code">
@app.Route("/user/add", methods: const [app.POST])
addUser(@app.Body(app.JSON) Map user) {
  ...
}</pre>
              <p>It's also possible to access the current request object</p>
              <pre class="prettyprint code">
@app.Route("/service", methods: const [app.GET, app.POST])
service() {
  if (app.request.method == app.GET) {
    ...
  } else if (app.request.method == app.POST) {

    if (app.request.bodyType == app.JSON) {
      var json = app.request.body;
      ...
    } else {
      ...
    }
  }
};</pre>
              <h3>Interceptors</h3>
              <p>Interceptors are useful when you need to apply a common behavior to a group of targets (functions or static content). For example, you can create an interceptor to apply a security constraint or to manage a resource</p>
              <pre class="prettyprint code">
@app.Interceptor(r'/admin/.*')
adminFilter() {
  if (app.request.session["username"] != null) {
    app.chain.next();
  } else {
    app.chain.interrupt(statusCode: HttpStatus.UNAUTHORIZED);
    //or app.redirect("/login.html");
  }
}</pre>
              <pre class="prettyprint code">
@app.Interceptor(r'/services/.+')
dbConnInterceptor() {
  var conn = new DbConn();
  app.request.attributes["dbConn"] = conn;
  app.chain.next(() => conn.close());
}

@app.Route('/services/find')
find(@app.Attr() dbConn) {
  ...
}</pre>
              <h3>Error handlers</h3>
              <p>Use the <code>@ErrorHandler</code> annotation to register error handlers.</p>
              <pre class="prettyprint code">
@app.ErrorHandler(404)
handleNotFoundError() => app.redirect("/error/not_found.html");</pre>
              <pre class="prettyprint code">
@app.ErrorHandler(500)
handleServerError() {
  print(app.chain.error);
  app.request.response.write("Server Error.");
}</pre>
              <h3>Groups</h3>
              <p>You can use classes to group routes, interceptors and error handlers.</p>
              <pre class="prettyprint code">
@Group("/user")
class UserService {

  @app.Route("/find")
  findUser(@app.QueryParam("n") String name,
           @app.QueryParam("c") String city) {
    ...
  }

  @app.Route("/add", methods: const [app.POST])
  addUser(@app.Body(app.JSON) Map json) {
    ...
  }
}</pre>
              <h3>Dependency Injection</h3>
              <p>Register one or more modules before calling <code>app.start()</code></p>
              <pre class="prettyprint code">
import 'package:redstone/server.dart' as app;
import 'package:di/di.dart';

main() {

  app.addModule(new Module()
       ..bind(ClassA)
       ..bind(ClassB));

  app.setupConsoleLog();
  app.start();

}</pre>
              <p>Routes, interceptors, error handlers and groups can require dependencies</p>
              <pre class="prettyprint code">
@app.Route('/service')
service(@app.Inject() ClassA objA) {
 ...
}</pre>
              <pre class="prettyprint code">
@app.Interceptor(r'/services/.+')
interceptor(ClassA objA, ClassB objB) {
  ...
}</pre>
              <pre class="prettyprint code">
@app.ErrorHandler(404)
notFound(ClassB objB) {
  ...
}</pre>
              <pre class="prettyprint code">
@app.Group('/group')
class Group {

  ClassA objA;

  Group(ClassA this.objA);

  @app.Route('/service')
  service() {
    ...
  }

}</pre>
              <h3>Unit tests</h3>
              <p>You can easily create mock requests to test your server</p>
              <pre class="prettyprint code">
library services;

import 'package:redstone/server.dart' as app;

@app.Route("/user/:username")
helloUser(String username) => "hello, $username";</pre>
              <pre class="prettyprint code">
import 'package:unittest/unittest.dart';

import 'package:redstone/server.dart' as app;
import 'package:redstone/mocks.dart';

import 'package:your_package_name/services.dart';

main() {

  //load handlers in 'services' library
  setUp(() => app.setUp([#services]));

  //remove all loaded handlers
  tearDown(() => app.tearDown());

  test("hello service", () {
    //create a mock request
    var req = new MockRequest("/user/luiz");
    //dispatch the request
    return app.dispatch(req).then((resp) {
      //verify the response
      expect(resp.statusCode, equals(200));
      expect(resp.mockContent, equals("hello, luiz"));
    });
  })

}</pre>
            </div>
          </div>
          <div id="reference" class="section">
            <h1 class="page-header">Reference</h1>
            <div id="routes" class="subsection">
              <h2>Routes</h2>
              <p>The <code>@Route</code> annotation is used to bind a function or method to an URL:</p>
              <pre class="prettyprint code">
@app.Route("/")
helloWorld() => "Hello, World!";</pre>
              <p>The returned value will be serialized to the client according to its type. For example, if the value is a String, the client will receive a text/plain response.</p>
              <table class="table table-condensed">
                <thead>
                  <tr>
                    <th>Returned value</th>
                    <th>Response type</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td>String</td>
                    <td>text/plain</td>
                  </tr>
                  <tr>
                    <td>Map or List</td>
                    <td>application/json</td>
                  </tr>
                  <tr>
                    <td>File</td>
                    <td>MimeType of the file</td>
                  </tr>
                </tbody>
              </table>
              <p>If a Future is returned, then the framework will wait for its completion.</p>
              <pre class="prettyprint code">
@app.Route("/")
helloWorld() => new Future(() => "Hello, World!");</pre>
              <p>For other types, Redstone.dart will convert the value to a String, and send it as <code>text/plain</code>.</p>
              <p>Also, it's possible to override the content type of the response:</p>
              <pre class="prettyprint code">
@app.Route("/", responseType: "text/xml")
getXml() => "&lt;root&gt;&lt;node&gt;text&lt;/node&gt;&lt;/root&gt;";</pre>
              <h3>Parameters</h3>
              <h4>Path Segments</h4>
              <p>It's possible to bind path segments with arguments:</p>
              <pre class="prettyprint code">
@app.Route("/user/:username")
helloUser(String username) => "hello $username";</pre>
              <p>The argument doesn't need to be a String. If it's an int, for example, the framework will try to convert the value for you (if the conversion fails, a 400 status code is sent to the client).</p>
              <pre class="prettyprint code">
@app.Route("/user/:username/:addressId")
getAddress(String username, int addressId) {
  ...
};</pre>
              <p>The supported types are: int, double and bool</p>
              <h4>Query parameters</h4>
              <p>Use the <code>@QueryParam</code> annotation to access a query parameter</p>
              <pre class="prettyprint code">
@app.Route("/user")
getUser(@app.QueryParam("id") int userId) {
  ...
};</pre>
              <p>Like path parameters, the argument doesn't need to be a String.</p>
              <h4>Request body</h4>
              <p>You can access the request body as a form, json or text</p>
              <pre class="prettyprint code">
@app.Route("/adduser", methods: const [app.POST])
addUser(@app.Body(app.JSON) Map json) {
  ...
};</pre>
              <pre class="prettyprint code">
@app.Route("/adduser", methods: const [app.POST])
addUser(@app.Body(app.FORM) Map form) {
  ...
};</pre>
              <h3>HTTP Methods</h3>
              <p>By default, a route only responds to GET requests. You can change that with the methods arguments:</p>
              <pre class="prettyprint code">
@app.Route("/user/:username", methods: const [app.GET, app.POST])
helloUser(String username) => "hello $username";</pre>
              <h3>Multipart requests (file uploads)</h3>
              <p>By default, Redstone.dart will refuse any multipart request. If your method needs to receive a multipart request, you can set <code>Route.allowMultipartRequest = true</code>. Example:</p>
              <pre class="prettyprint code">
@app.Route("/adduser", methods: const [app.POST], allowMultipartRequest: true)
addUser(@app.Body(app.FORM) Map form) {
  var file = form["file"];
  print(file.filename);
  print(file.contentType);
  print(file.content);
  ...
};</pre>
              <h3>Matching sub paths</h3>
              <p>If you set <code>Route.matchSubPaths = true</code>, then the route will matches requests which path starts with the URL pattern. Example:</p>
              <pre class="prettyprint code">
@app.Route('/path', matchSubPaths: true)
service() {
 ...
}

@app.Route('/path/subpath')
serviceB() {
 ...
}</pre>
              <p>If a request for <code>/path/subpath</code> is received, then <code>serviceB</code> is executed, but if a request for <code>/path/another_path</code> is received, <code>service</code> is executed.</p>
              <h3>The request object</h3>
              <p>You can use the global <code>request</code> object to access the request's information and content:</p>
              <pre class="prettyprint code">
@app.Route("/user", methods: const [app.GET, app.POST])
user() {
  if (app.request.method == app.GET) {
    ...
  } else if (app.request.method == app.POST) {

    if (app.request.bodyType == app.JSON) {
      var json = app.request.body;
      ...
    } else {
      ...
    }
  }
};</pre>
              <p>Each request is tied to its own <a href="https://www.dartlang.org/articles/zones/">Zone</a>, so it's also safe to access the request object in async operations.</p>
            </div>
            <div id="interceptors" class="subsection">
              <h2>Interceptors</h2>
              <p>The <code>@Interceptor</code> annotation is used to define an interceptor:</p>
              <pre class="prettyprint code">
@app.Interceptor(r'/.*')
handleResponseHeader() {
  app.request.response.headers.add("Access-Control-Allow-Origin", "*");
  if (app.request.method == "OPTIONS") {
    app.chain.interrupt();
  } else {
    app.chain.next();
  }
}</pre>
              <h3>The chain object</h3>
              <p>Each request is actually a chain, composed by 0 or more interceptors, and a target. A target is a function annotated with <code>@Route</code>, or a static file. An interceptor is a structure that allows you to apply a common behavior to a group of targets. For example, you can use an interceptor to apply a security constraint, or to manage a resource:</p>
              <pre class="prettyprint code">
@app.Interceptor(r'/admin/.*')
adminFilter() {
  if (app.request.session["username"] != null) {
    app.chain.next();
  } else {
    app.chain.interrupt(statusCode: HttpStatus.UNAUTHORIZED);
    //or app.redirect("/login.html");
  }
}</pre>
              <pre class="prettyprint code">
@app.Interceptor(r'/services/.+')
dbConnInterceptor() {
  var conn = new DbConn();
  app.request.attributes["dbConn"] = conn;
  app.chain.next(() => conn.close());
}

@app.Route('/services/find')
find(@app.Attr() dbConn) {
  ...
}</pre>
              <p>When a request is received, the framework will execute all interceptors that matches the URL, and then will look for a valid route. If a route is found, it will be executed, otherwise the server will look for a static file.</p>
              <p>Each interceptor must call the <code>chain.next()</code> or <code>chain.interrupt()</code> methods, otherwise, the request will be stuck. The <code>chain.next()</code> method can receive a callback, that is executed when the target completes. All callbacks are executed in the reverse order they are created. If a callback returns a <code>Future</code>, then the next callback will execute only when the future completes.</p>
              <p>For example, consider this script:</p>
              <pre class="prettyprint code">
@app.Route("/")
helloWorld() => "target\n";

@app.Interceptor(r'/.*', chainIdx: 0)
interceptor1() {
  app.request.response.write("interceptor 1 - before target\n");
  app.chain.next(() {
    app.request.response.write("interceptor 1 - after target\n");
  });
}

@app.Interceptor(r'/.*', chainIdx: 1)
interceptor2() {
  app.request.response.write("interceptor 2 - before target\n");
  app.chain.next(() {
    app.request.response.write("interceptor 2 - after target\n");
  });
}

main() {

  app.setupConsoleLog();
  app.start();

}</pre>
              <p>When you access <a href="http://127.0.0.1:8080/">http://127.0.0.1:8080/</a>, the result is:</p>
              <pre class="code">
interceptor 1 - before target
interceptor 2 - before target
target
interceptor 2 - after target
interceptor 1 - after target</pre>
              <p>It's also possible to verify if the target threw an error (if there is an error handler registered, it will be invoked before the callback):</p>
              <pre class="prettyprint code">
@app.Interceptor(r'/.*')
interceptor() {
  app.chain.next(() {
    if (app.chain.error != null) {
      ...
    }
  });
}</pre>
              <h3>The request body</h3>
              <p>By default, Redstone.dart won't parse the request body until all interceptors are called. If your interceptor need to inspect the request body, you must set <code>parseRequestBody = true</code>. Example:</p>
              <pre class="prettyprint code">
@app.Interceptor(r'/service/.+', parseRequestBody: true)
verifyRequest() {
  //if parseRequestBody is not setted, request.body is null
  print(app.request.body);
  app.chain.next();
}</pre>
            </div>
            <div id="error_handlers" class="subsection">
              <h2>Error Handlers</h2>
              <p>The <code>@ErrorHandler</code> annotation is used to define an error handler:</p>
              <pre class="prettyprint code">
@app.ErrorHandler(HttpStatus.NOT_FOUND)
handleNotFoundError() => app.redirect("/error/not_found.html");</pre>
              <p>Also, you can define an error handler for a specific URL pattern</p>
              <pre class="prettyprint code">
@app.ErrorHandler(HttpStatus.NOT_FOUND, urlPattern: r'/public/.+')
handleNotFoundError() => app.redirect("/error/not_found.html");</pre>
              <p>If you define an error handler inside a group, then the handler will be restricted to the group path.</p>
              <pre class="prettyprint code">
@app.Group('/user')
class User {

  @app.ErrorHandler(500)
  onInternalServerError() {
    if (app.chain.error is UserException) {
      ...
    } 
  }

  @app.Route('/find')
  find() {
    ...
  }
}</pre>
              <p>When an error happens, Redstone will invoke the most specific handler for the request.</p>
            </div>
            <div id="groups" class="subsection">
              <h2>Groups</h2>
              <p>The <code>@Group</code> annotation is used to define a group of routes, interceptors and error handlers:</p>
              <pre class="prettyprint code">
@Group("/user")
class UserService {

  @app.Route("/find")
  findUser(@app.QueryParam("n") String name,
           @app.QueryParam("c") String city) {
    ...
  }

  @app.Route("/add", methods: const [app.POST])
  addUser(@app.Body(app.JSON) Map json) {
    ...
  }
}</pre>
              <p>The prefix defined with the <code>@Group</code> annotation, will be prepended in every route and interceptor inside the group.</p>
            </div>
            <div id="dependency_injection" class="subsection">
              <h2>Dependency Injection</h2>
              <p>Redstone.dart uses the <a href="http://pub.dartlang.org/packages/di">di package</a> to provide dependency injection.</p>
              <p>To register a module, use the <code>addModule()</code> method:</p>
              <pre class="prettyprint code">
import 'package:redstone/server.dart' as app;
import 'package:di/di.dart';

main() {

  app.addModule(new Module()
       ..bind(ClassA)
       ..bind(ClassB));

  app.setupConsoleLog();
  app.start();

}</pre>
              <p>For methods annotated with <code>@Route</code>, you can inject objects using the <code>@Inject</code> annotation:</p>
              <pre class="prettyprint code">
@app.Route('/service')
service(@app.Inject() ClassA objA) {
 ...
}</pre>
              <p>Groups can require objects using a constructor:</p>
              <pre class="prettyprint code">
@app.Group('/group')
class Group {

  ClassA objA;

  Group(ClassA this.objA);

  @app.Route('/service')
  service() {
    ...
  }

}</pre>
              <p>Interceptors and error handlers can also require dependencies:</p>
              <pre class="prettyprint code">
@app.Interceptor(r'/services/.+')
interceptor(ClassA objA, ClassB objB) {
  ...
}


@app.ErrorHandler(404)
notFound(ClassB objB) {
  ...
}</pre>
            </div>
            <div id="importing_libraries" class="subsection">
              <h2>Importing Libraries</h2>
              <p>Redstone.dart recursively scans all libraries imported by your main script. Example:</p>
              <ul>
                <li>server.dart</li>
              </ul>
              <pre class="prettyprint code">
import 'package:redstone/server.dart' as app;
//all handlers in services.dart will be installed
import 'package:myapp/services.dart';

main() {
  app.setupConsoleLog();
  app.start();
}</pre>
              <ul>
                <li>services.dart</li>
              </ul>
              <pre class="prettyprint code">
import 'package:redstone/server.dart' as app;

@app.Route("/user/find")
findUser() {
  ...
}</pre>
              <p>However, sometimes you need more control on how handlers from other libraries are installed. In these cases, you can use the <code>@Install</code> annotation:</p>
              <pre class="prettyprint code">
import 'package:redstone/server.dart' as app;
//all handlers in services.dart will be installed under the '/services' path
@app.Install(urlPrefix: '/services')
import 'package:myapp/services.dart';

main() {
  app.setupConsoleLog();
  app.start();
}</pre>
              <p>If the library defines interceptors, you can control the execution order:</p>
              <pre class="prettyprint code">
import 'package:redstone/server.dart' as app;

@app.Install(chainIdx: 1)
import 'package:myapp/services.dart';

//this interceptor will be invoked first
@app.Interceptor("/.+", chainIdx: 0)
interceptor() {
  app.request.response.write("interceptor 1");
  app.chain.next();
}

main() {
  app.setupConsoleLog();
  app.start();
}</pre>
              <ul>
                <li>services.dart</li>
              </ul>
              <pre class="prettyprint code">
import 'package:redstone/server.dart' as app;

@app.Interceptor("/.+", chainIdx: 0)
interceptor() {
  app.request.response.write("interceptor 2");
  app.chain.next();
}

@app.Interceptor("/.+", chainIdx: 1)
interceptor2() {
  app.request.response.write("interceptor 3");
  app.chain.next();
}</pre>
              <p>If you want to import a library, but don't need its handlers, you can use the <code>@Ignore</code> annotation:</p>
              <pre class="prettyprint code">
import 'package:redstone/server.dart' as app;
//handlers defined in services.dart won't be installed
@app.Ignore()
import 'package:myapp/services.dart';

main() {
  app.setupConsoleLog();
  app.start();
}</pre>
              <p>A library is installed only once. So, if you import the same library in different files, its handlers won't be installed twice:</p>
              <pre class="prettyprint code">
import 'package:redstone/server.dart' as app;
import 'package:myapp/lib_a.dart';
import 'package:myapp/lib_b.dart';

main() {
  app.setupConsoleLog();
  app.start();
}</pre>
              <ul>
                <li>lib_a.dart</li>
              </ul>
              <pre class="prettyprint code">
library lib_a;
import 'package:redstone/server.dart' as app;
import 'package:myapp/lib_c.dart';

@app.Route(...)
serviceA() {
  ...
}</pre>
              <ul>
                <li>lib_b.dart</li>
              </ul>
              <pre class="prettyprint code">
library lib_b;
import 'package:redstone/server.dart' as app;
import 'package:myapp/lib_c.dart';

@app.Route(...)
serviceB() {
  ...
}</pre>
              <ul>
                <li>lib_c.dart</li>
              </ul>
              <pre class="prettyprint code">
//lib_c is imported by lib_a and lib_b, but its handlers are installed only once.
library lib_c;
import 'package:redstone/server.dart' as app;

@app.Interceptor(...)
interceptor() {
  ...
}</pre>
            </div>
            <div id="plugins" class="subsection">
              <h2>Plugins</h2>
              <p>Redstone plugins can dynamically create new routes, interceptors, error handlers, parameter providers and response processors.</p>
              <p>For example, if your app often needs to convert from json data to Dart objects, like this:</p>
              <pre class="prettyprint code">
@app.Route("/user", methods: const[app.POST])
printUser(@app.Body() Map json) {
  User user = new User();
  user.fromJson(json);
  ...
}</pre>
              <p>You can build a plugin to do this job for you. Example:</p>
              <pre class="prettyprint code">
class FromJson {
  
  const FromJson();
  
}

FromJsonPlugin(app.Manager manager) {
  
  manager.addParameterProvider(FromJson, (metadata, type, handlerName, paramName, req, injector) {
    if (req.bodyType != app.JSON) {
      throw new app.RequestException(
          "FromJson plugin - $handlerName", "content-type must be 'application/json'");
    }
    
    ClassMirror clazz = reflectClass(type);
    InstanceMirror obj = clazz.newInstance(const Symbol(""), const []);
    obj.invoke(#fromJson, [req.body]);
    return obj.reflectee;
  });
  
}</pre>
              <p>Now, if you install <code>FromJsonPlugin</code>, you can use the <code>@FromJson</code> annotation:</p>
              <pre class="prettyprint code">
@app.Route("/user", methods: const[app.POST])
printUser(@FromJson() User user) {
  ...
}

main() {
  app.addPlugin(FromJsonPlugin);
  app.setupConsoleLog();
  app.start();
}</pre>
              <p>Besides, you can also build a plugin to convert from dart objects to json data:</p>
              <pre class="prettyprint code">
class ToJson {
  
  const ToJson();
  
}

ToJsonPlugin(app.Manager manager) {
  manager.addResponseProcessor(ToJson, (metadata, handlerName, value, injector) {
    if (value == null) {
      return value;
    }
    return value.toJson();
  });
}</pre>
              <pre class="prettyprint code">
@app.Route("/user/find")
@ToJson()
findUser() {
  return new Future(() {
    ...
    return user;
  });
}

main() {
  app.addPlugin(ToJsonPlugin);
  app.setupConsoleLog();
  app.start();
}</pre>
            </div>
            <div id="unit_test" class="subsection">
              <h2>Unit Test</h2>
              <p>Basically, to create a test, you just need to:</p>
              <ul>
                <li>Call <code>setUp()</code> to load your handlers</li>
                <li>Create a <code>MockRequest</code></li>
                <li>Call <code>dispatch()</code> to send your request</li>
                <li>Inspect the returned response</li>
                <li>Call <code>tearDown()</code> to unload your handlers</li>
              </ul>
              <p>Example:</p>
              <pre class="prettyprint code">
library services;

import 'package:redstone/server.dart' as app;

@app.Route("/user/:username")
helloUser(String username) => "hello, $username";</pre>
              <pre class="prettyprint code">
import 'package:unittest/unittest.dart';

import 'package:redstone/server.dart' as app;
import 'package:redstone/mocks.dart';

import 'package:your_package_name/services.dart';

main() {

  //load handlers in 'services' library
  setUp(() => app.setUp([#services]));

  //remove all loaded handlers
  tearDown(() => app.tearDown());

  test("hello service", () {
    //create a mock request
    var req = new MockRequest("/user/luiz");
    //dispatch the request
    return app.dispatch(req).then((resp) {
      //verify the response
      expect(resp.statusCode, equals(200));
      expect(resp.mockContent, equals("hello, luiz"));
    });
  })

}</pre>
            </div>
            <div id="server_configuration" class="subsection">
              <h2>Server Configuration</h2>
              <p>If you invoke the <code>start()</code> method with no arguments, the server will be configured with default values:</p>
              <table class="table table-condensed">
                <thead>
                  <tr>
                    <th>Argument</th>
                    <th>Default value</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td>host</td>
                    <td>"0.0.0.0"</td>
                  </tr>
                  <tr>
                    <td>port</td>
                    <td>8080</td>
                  </tr>
                  <tr>
                    <td>staticDir</td>
                    <td>"../web"</td>
                  </tr>
                  <tr>
                    <td>indexFiles</td>
                    <td>["index.html"]</td>
                  </tr>
                  <tr>
                    <td>followLinks</td>
                    <td>false</td>
                  </tr>
                  <tr>
                    <td>jailRoot</td>
                    <td>true</td>
                  </tr>
                </tbody>
              </table>
              <p>During development, you will probably need to set <code>followLinks = true</code> and <code>jailRoot = false</code>, since Dartium will request for .dart files that are not in web folder. Although, doing so in production environment can lead to security issues.</p>
              <h3>Logging</h3>
              <p>Redstone.dart provides a helper method to set a simple log handler, that outputs the messages to the console:</p>
              <pre class="prettyprint code">
app.setupConsoleLog();</pre>
              <p>By default, the log level is setted to INFO, which logs the startup process and errors. If you want to see all the log messages, you can set the level to ALL:</p>
              <pre class="prettyprint code">
import 'package:logging/logging.dart';


main() {
  app.setupConsoleLog(Level.ALL);
  ...
}</pre>
              <p>If you want to output the messages to a different place (for example, a file), you can define your own log handler:</p>
              <pre class="prettyprint code">
Logger.root.level = Level.ALL;
Logger.root.onRecord.listen((LogRecord rec) {
  ...
});</pre>
            </div>
            <div id="deploy" class="subsection">
              <h2>Deploy</h2>
              <p>The easiest way to build your app is using the <a href="http://pub.dartlang.org/packages/grinder">grinder</a> library. Redstone.dart provides a simple task to properly copy the server's files to the build folder, which you can use in your build script. Example:</p>
              <ul>
                <li>Create a <code>build.dart</code> file inside the <code>bin</code> folder</li>
              </ul>
              <pre class="prettyprint code">
import 'package:grinder/grinder.dart';
import 'package:grinder/grinder_utils.dart';
import 'package:redstone/tasks.dart';

main(List&lt;String&gt; args) {
  defineTask('build', taskFunction: (GrinderContext ctx) => new PubTools().build(ctx));
  defineTask('deploy_server', taskFunction: deployServer, depends: ['build']);
  defineTask('all', depends: ['build', 'deploy_server']);

  startGrinder(args);
}</pre>
              <ul>
                <li>Instead of running <code>pub build</code> directly, you can call <code>build.dart</code> to properly build your app.</li>
                <li>To run <code>build.dart</code> through Dart Editor, you need to create a command-line launch configuration, with the following parameters:</li>
              </ul>
              <table class="table table-condensed">
                <thead>
                  <tr>
                    <th>Parameter</th>
                    <th>Values</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td>Dart Script</td>
                    <td>bin/build.dart</td>
                  </tr>
                  <tr>
                    <td>Working directory</td>
                    <td><i>root path of your project</i></td>
                  </tr>
                  <tr>
                    <td>Script arguments</td>
                    <td>all</td>
                  </tr>
                </tbody>
              </table>
              <ul>
                <li>To run <code>build.dart</code> through command line, you need to set the DART_SDK environment variable:</li>
              </ul>
              <pre class="code">
$ export DART_SDK=(path to dart-sdk)
$ dart bin/build.dart all</pre>
              <h3>DartVoid</h3>
              <p>If you plan to deploy your app at <a href="http://www.dartvoid.com/">DartVoid</a>, you won't need a build script (since DartVoid will manage the deploy for you), but you will need to split your app in two projects: <code>server</code> and <code>client</code>.</p>
              <p>DartVoid provides a set of templates (built with the <a href="http://www.dartvoid.com/vane/">Vane</a> framework) that you can use to bootstrap your app. Below, you can see some of these templates ported to Redstone.dart:</p>
              <ul>
                <li><a href="https://github.com/luizmineo/dartvoid-helloworld">Hello World</a></li>
                <li><a href="https://github.com/luizmineo/dartvoid-guestbook">Guestbook</a></li>
                <li><a href="https://github.com/luizmineo/dartvoid-mongo-todo">Todo List</a></li>
              </ul>
            </div>
          </div>
        </div>
      </div>
    </div>

    <div class="container-fluid footer">
      <div class="row">
        <div class="col-xs-12">
          <div class="footer-panel">
            <ul class="gh-links">
              <li>
                <iframe src="http://ghbtns.com/github-btn.html?user=luizmineo&repo=redstone.dart&type=watch&count=true" allowtransparency="true" frameborder="0" scrolling="0" width="110" height="20"></iframe>
              </li>
              <li>
                <iframe src="http://ghbtns.com/github-btn.html?user=luizmineo&repo=redstone.dart&type=fork&count=true" allowtransparency="true" frameborder="0" scrolling="0" width="110" height="20"></iframe>
              </li>
              <li>
                <iframe src="http://ghbtns.com/github-btn.html?user=luizmineo&repo=redstone.dart&type=follow" allowtransparency="true" frameborder="0" scrolling="0" width="150" height="20"></iframe>
              </li>
            </ul>
            <p>Built and mantained by <a href="https://github.com/luizmineo" target="_blank">Luiz Mineo</a>. Code licensed under <a href="https://github.com/luizmineo/redstone.dart/blob/master/LICENSE" target="_blank">MIT</a>.</p>
            <ul class="footer-links">
              <li>Currently v0.4.0</li>
              <li>-</li>
              <li><a href="https://github.com/luizmineo/redstone.dart">Github</a></li>
              <li>-</li>
              <li><a href="documentation.html">Documentation</a></li>
              <li>-</li>
              <li><a href="api/index.html">API Reference</a></li>
            </ul>
          </div>
        </div>
      </div>
    </div>


    <script src="js/jquery-1.11.0.min.js"></script>
    <script src="js/bootstrap.min.js"></script>
    <script src="js/lang-dart.js"></script>
    <script src="js/prettify.js"></script>
    <script src="js/run_prettify.js"></script>

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-50600290-1', 'luizmineo.github.io');
      ga('send', 'pageview');

    </script>
  </body>
</html>